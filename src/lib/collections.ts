import { glob } from "glob";
import matter from "gray-matter";
import * as path from "node:path";
import * as fs from "node:fs/promises";
import slugify from "@sindresorhus/slugify";

import type { MiniItem, Server } from "./schema";
import { MiniItemSchema, ServerSchema } from "./schema";
import { z } from "zod";

const SERVERS_COLLECTION_DIR_URL = "src/content/servers";

export async function getServerEntries() {
	const files = await glob(path.join(SERVERS_COLLECTION_DIR_URL, "**/*.md"));

	// Read each file and parse it with gray-matter
	const entries = await Promise.all(
		files.map(async (file) => {
			const content = await fs.readFile(file, "utf-8");
			const { data, content: body } = matter(content);
			return { ...data, body };
		}),
	);

	return entries;
}

function getSlugsFromRepoUrl(rawRepoUrl: string): { name: string; owner: string } {
	// Assert that the repoUrl is a valid GitHub repo URL
	const repoUrl = z
		.string()
		.url()
		// Assert that we have at least 2 path parts after the domain
		.refine((url) => {
			const urlPath = new URL(url).pathname;
			return urlPath.split("/").length >= 2;
		})
		.parse(rawRepoUrl);

	// Split the repoUrl into owner and name
	const [owner, name] = repoUrl.split("/").slice(-2);
	return { name, owner };
}

function makeServerFileName(server: Server): `${string}---${string}.md` {
	const { name, owner } = getSlugsFromRepoUrl(server.repoUrl);
	return `${name}---${owner}.md`;
}

export async function writeServerEntries(repos: MiniItem[]) {
	// Assert that the entries are valid
	const entries = MiniItemSchema.array().parse(repos);

	// Convert repos to servers
	const servers = ServerSchema.array().parse(
		entries.map((entry) => {
			return {
				title: entry.name,
				repoUrl: entry.html_url,
				// Use description from entry, default to empty
				description: entry.description ?? "",
				verifications: [],
				lastUpdated: new Date().toISOString(),
				ogImage: "",
			} satisfies Server;
		}),
	);

	// Write the entries to the collection
	// Loop through servers, not entries, to use the processed data
	for (const server of servers) {
		// Use gray-matter to format the frontmatter
		// Pass the server object as data, empty string as content
		const content = matter.stringify("", server);

		// Use server.title which matches the 'name' used above
		await fs.writeFile(
			path.join(SERVERS_COLLECTION_DIR_URL, makeServerFileName(server)),
			content, // Use the content generated by gray-matter
		);
	}
}
